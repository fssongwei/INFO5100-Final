<!DOCTYPE html>
<html>
<head>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <script src="https://d3js.org/topojson.v3.min.js"></script>
    <script src="https://d3js.org/d3-collection.v1.min.js"></script>
    <style>
        body {
            font-family: Arial, Helvetica, sans-serif;
        }

        .countries {
            fill: #ededed;
        }
  
        .border {
            stroke: #1c1c1c;
            stroke-width: 1px;
            fill: none;
        }

        .countryInfo {
            fill: white;
            text-anchor: middle;
            align-items: hanging;
        }

        #colorLegend {
			margin: 20px;
		}

        .legend span {
            margin-right: 10px;
        }

        .custom-select {
            width: 200px;
            position: relative;          
            margin-bottom: 30px;
        }

        .bar-title {
            font-size: 20px;
            font-weight: 900;
            margin-bottom: 10px;
            margin-top: 20px;
        }

        #regionbar {
            height: 40px;
            font-size: 15px;
        }

        .select-selected {
            background-color: DodgerBlue;
        }
    </style>
</head>
<body>
    <div id="container">
        <div>
          <h2> World Map of the Happiness Score &#128516</h2>
        </div>
        <div class="custom-select" style="width:200px;">
            <p class="bar-title">World Region:</p>
            <select id="regionbar">
                <option value="all">View All</option>
                <option value="North America">North America</option>
                <option value="Latin America and Caribbean">Latin America and Caribbean</option>
                <option value="Sub-Saharan Africa">Sub-Saharan Africa</option>
                <option value="Middle East and Northern Africa">Middle East and Northern Africa</option>
                <option value="Eastern Asia">Eastern Asia</option>
                <option value="Southeastern Asia">Southeastern Asia</option>
                <option value="Central and Eastern Europe">Central and Eastern Europe</option>
                <option value="Western Europe">Western Europe</option>
                <option value="Australia and New Zealand">Australia and New Zealand</option>
            </select>
        </div>

        <div id="mapCanvas">
          <svg id="map" width="700" height="525"></svg>
        </div>
        <div>
            <svg id="colorLegend" height="80" width="500"></svg>
        </div>
    </div>
    <script>
        // basic operations to get the svg and set margins
        // append g for inner map
        const map = d3.select("#map");
        const width = parseInt(map.attr("width"));
        const height = parseInt(map.attr("height"));
        const margin = { top: 20, right: 20, bottom: 20, left: 20 };
        const mapWidth = width - margin.left - margin.right;
        const mapHeight = height - margin.top - margin.bottom;
        const innerMap = map.append("g")
            .attr("transform", "translate(" + margin.left + "," + margin.top + ")");
        
        // request data asynchronously
        const requestData = async function () {
            const happiness = await d3.csv("./data/joined.csv")
            const world = await d3.json("./data/world.json");
            const code = await d3.json("./data/countryCode.json");
            console.log(happiness);
            console.log(code);
        

            // create a Map to store country codes as keys with country names as values
            var code_country_map = new Map();
            code.forEach(country => {
                code_country_map.set(country['country-code'], country['name']);
            });

            // create a Map to store country regions as keys with country names Set as value
            var region_countries_map = new Map();
            happiness.forEach(d => {
                if (!region_countries_map.has(d.Region)) {
                    region_countries_map.set(d.Region, new Set());
                } 
                region_countries_map.get(d.Region).add(d['Country name']);
            });

            // create a Map to record with country names as key and happiness score as value
            var countryHappyMap = new Map();
            
            // array of all happiness scores for color domain later
            var happinessArr = [];

            // get max and min happiness score and put keys and values into the Map
            happiness.forEach(element => {
                countryHappyMap.set(element['Country name'], parseFloat(element["HappinessScore"]));
                happinessArr.push(parseFloat(element["HappinessScore"]));
            })

            // get feature, mesh, and projection
            var countries = topojson.feature(world, world.objects.countries);
            world.objects.countries.geometries = world.objects.countries.geometries.filter(country => countryHappyMap.has(code_country_map.get(country.id)));
            var countriesMesh = topojson.mesh(world, world.objects.countries);
            var projection = d3.geoMercator().fitSize([mapWidth, mapHeight], countries);
            
            // create path based on projection
            var path = d3.geoPath().projection(projection);

            // draw countries on the map
            innerMap.selectAll("path.countries").data(countries.features)
                .join("path")
                .attr("class", "countries")
                .attr("d", path);

            // draw the border of each country
            innerMap.append("path").datum(countriesMesh)
                .attr("class", "border")
                .attr("d", path);

            // create tooltip and country information text
            let tooltipWidth = 280;
            let tooltipHeight = 150;

            let momesh = innerMap.append("path")
                .attr("class", "mouseover border");
            
            let tooltip = innerMap.append("g")
                .attr("class", "tooltip")
                .attr("visibility", "hidden");
            
            tooltip.append("rect")
                .attr("x", -tooltipWidth / 2.0)
                .attr("y", 0)
                .attr("width",tooltipWidth)
                .attr("height",tooltipHeight)
                .attr("opacity", 0.9)
                .attr("fill", "#787A91")

            let txt = tooltip.append("text")
                .attr("class", "countryInfo")
                .attr("x", 0)
                .attr("y", 20);
        
            let txt2 = tooltip.append("text")
                .attr("class", "countryInfo")
                .attr("x", 0)
                .attr("y", 45);

            let txt3 = tooltip.append("text")
                .attr("class", "countryInfo")
                .attr("x", 0)
                .attr("y", 70);

            let txt4 = tooltip.append("text")
                .attr("class", "countryInfo")
                .attr("x", 0)
                .attr("y", 95);

            let txt5 = tooltip.append("text")
                .attr("class", "countryInfo")
                .attr("x", 0)
                .attr("y", 120);

            // create color scale
            const colorArr = ['#FDF6F0', '#FBFFE2', '#FFF9B6', '#FFE699', '#FFD07F', '#FDA65D', '#FF8243', '#E26A2C'];
			const colorScale = d3.scaleQuantile().domain(happinessArr).range(colorArr);
			
            // draw legend of the map
			drawLegend(d3.select('#colorLegend'), colorScale);

            // fill each country with different colors based on happiness score
            innerMap.selectAll(".countries")
                .style("fill", d =>  colorScale(countryHappyMap.get(code_country_map.get(d.id))));
            
            // update function for drop down bar
            var updateMap = function(region) {
                if (region === "all") {
                    innerMap.selectAll(".countries")
                        .style("fill", d => colorScale(countryHappyMap.get(code_country_map.get(d.id))));
                } else {
                    innerMap.selectAll(".countries")
                        .style("fill", d => (region_countries_map.get(region).has(code_country_map.get(d.id))) ? 
                        colorScale(countryHappyMap.get(code_country_map.get(d.id))) : null);
                } 
            }
            
            // fill a specific region based on the drop down bar selection
            d3.select("#regionbar").on("change", function() {
                var newRegion = d3.select(this).property('value');
                updateMap(newRegion);
            });

            // mouse over and out from a specific country and get the tooltip
            d3.selectAll(".countries").on("mouseenter", mouseEnters);
            d3.selectAll(".countries").on("mouseout", mouseLeaves);
            
            // mouse enter function
            function mouseEnters() {
                let country = d3.select(this);
                if (countryHappyMap.has(code_country_map.get(country.datum().id))) {
                    tooltip.style("visibility", "visible");
                    country.attr("stroke", "black")
                           .attr("stroke-width", 3)
                           .style("opacity", 0.5)
                }
                let countryName = code_country_map.get(country.datum().id);

                // get information of mouse-over country
                if (countryHappyMap.has(countryName)) {
                    var life;
                    var socialSupport;
                    var freedom;
                    happiness.forEach(d => {
                        if (d['Country name'] == countryName) {
                            life = d['Healthy life expectancy'];
                            socialSupport = d['Social support']
                            freedom = d['Freedom to make life choices'];
                        }
                    });
                    txt.text(countryName);
                    txt2.text("Happiness Score: " + countryHappyMap.get(countryName))
                    txt3.text("Life Expectancy: " + life);
                    txt4.text("Social Support: " + socialSupport);
                    txt5.text("Freedom to make life choices: " + freedom);
                }
                
                let bounds = path.bounds(country.datum());
                let xPos = (bounds[0][0] + bounds[1][0]) / 3.0;
                let yPos = bounds[1][1];
                tooltip.attr("transform", `translate(${xPos},${yPos})`);
                var mo = topojson.mesh(world, world.objects.countries, function (a, b) { return a.id === country.datum().id || b.id === country.datum().id; });
                momesh.datum(mo).attr("d", path);
            }

            // mouse out function 
            function mouseLeaves() {
                tooltip.style("visibility", "hidden");
                let country = d3.select(this);

                if (countryHappyMap.has(code_country_map.get(country.datum().id))) {
                    country.attr("stroke", "black")
                           .attr("stroke-width", 1)
                           .style("opacity", 1)
                }
                // momesh.attr("d", "");
            }
        }
        requestData();

        // function of drawing the legend
        function drawLegend(legend, legendColorScale) {
			const legendWidth = legend.attr('width');
			const legendHeight = legend.attr('height');
			const legendMinMax = d3.extent(legendColorScale.domain());
			const barHeight = 40;
			const stepSize = 4;

			// Extend the minmax by 1 in either direction to expose more features
			// create pixel and bar scale
			const pixelScale = d3.scaleLinear()
				                .domain([0, legendWidth - 40])
				                .range([legendMinMax[0], legendMinMax[1]]);
			const barScale = d3.scaleLinear()
                                .domain([legendMinMax[0], legendMinMax[1]])
                                .range([0, legendWidth - 40]);
			const barAxis = d3.axisBottom(barScale);

			// Check if we're using a quantile scale
			if (legendColorScale.hasOwnProperty('quantiles')) {

				// Use the quantile breakpoints plus the min and max of the scale as tick values
				barAxis.tickValues(legendColorScale.quantiles().concat(legendMinMax));
			}
			legend.append('g')
				.attr('class', 'colorbar axis')
				.attr('transform', 'translate(' + 20 + ',' + (barHeight + 5) + ')')
				.call(barAxis);

			// Draw rects of color down the bar
			let bar = legend.append('g').attr('transform', 'translate(' + 20 + ',' + 0 + ')');
			for (let i = 0; i < legendWidth - 40; i = i + stepSize) {
				bar.append('rect')
					.attr('x', i)
					.attr('y', 0)
					.attr('width', stepSize)
					.attr('height', barHeight)
					.style('fill', legendColorScale(pixelScale(i))); // pixels => countData => color
			}
		}
    </script>
</body>
</html>